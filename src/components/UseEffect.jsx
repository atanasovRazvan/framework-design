import {useEffect, useRef, useState, useContext} from "react";
import PaddedDiv from "./PaddedDiv";
import {sleep} from "../utils";
import {GlobalContext} from "../store/GlobalContext";

const COLORS = Object.freeze(["red", "green"]);

const UseEffect = ({ setDeleted }) => {
    const [color, setColor] = useState(0);
    const [initialText, setInitialText] = useState("Waiting for data...")
    const isInitialMount = useRef(true);
    const { background } = useContext(GlobalContext);

    useEffect(() => {
        sleep(2500).then(() => {
            setInitialText("The data is here!")
        })
    }, []);

    useEffect(() => {
        if (isInitialMount.current) {
            isInitialMount.current = false;
        } else {
            sleep(2500).then(() => {
                setColor(1-color);
            })
        }
    }, [color]);

    useEffect(() => {
        return () => {
            alert("This is an alert generated by the useEffect!");
        }
    }, []);

    return (
        <PaddedDiv title={"useEffect - does not trigger re-renders for other components"}>
            <div className={`flex flex-col items-center gap-5 bg-${background}-100 p-5`}>
                <div>
                    <strong>useEffect</strong> is responsible to handle custom re-renders. Effects can be of<br/>
                    three different kinds: at load time - dependency parameter is an empty array, on update -<br/>
                    dependency array contains state / props, on unmount - the handler callback is returned.
                </div>

                <hr className={"w-96"}/>

                <div>
                    Here is the first example, look how this text below will change after 2.5 seconds after <br/>
                    loading the page! This is a classic example of an on-load usage of useEffect, usually when <br/>
                    you wait for server data.
                </div>

                <div className={"bg-green-400 p-5"}>
                    {initialText}
                </div>

                <hr className={"w-96"}/>

                <div>
                    Now, an update example. Clicking the button will change the color, but will also start <br/>
                    executing the function inside the useEffect, that changes the color back to red after <br/>
                    2,5 seconds.
                </div>

                <button
                    className="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded"
                    onClick={() => setColor(1 - color)}
                >
                    Click me to change the state!
                </button>

                <div className={`w-fit p-2 h-10 bg-${COLORS[color]}-600`}>
                    Look how I change!
                </div>

                <hr className={"w-96"}/>

                <div>
                    Lastly, here is an example with unmount. Press the button to delete this component!
                </div>

                <button
                    className="bg-red-800 hover:bg-red-500 text-white font-bold py-2 px-4 rounded"
                    onClick={() => setDeleted(true)}
                >
                    Delete component!
                </button>

            </div>
        </PaddedDiv>
    )
}

export default UseEffect;